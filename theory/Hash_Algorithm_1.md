> 网站是怎么存储用户的密码这些重要数据的呢，仅仅 MD5 加密一下存储就够了吗？

#### 1. 什么是哈希算法？

首先，我们要明确一个概念，不管是 “散列” 还是 “哈希”，其实都是英文 “Hash” 的中文翻译，它们其实是一个意思。

所谓哈希算法，**其实就是将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值**。

要设计出一个优秀的哈希算法并不容易，一般需要满足以下几点要求：

- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
- 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

我们以 MD5 哈希来验证一下上面的结论。给出两个文本 “今天我来讲哈希算法” 和 “jiajia”，我们可以分别得到他们的哈希值。 MD5 的哈希值是 128 位的 Bit 长度，这里我们将其转化为了十六进制编码。

```
MD5("今天我来讲哈希算法") = bb4767201ad42c74e650c1b6c03d78fa
MD5("jiajia") = cd611a31ea969b908932d44d126d195b
```
可以看到，无论要哈希的文本有多长、多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律。

再来看两个非常相似的文本， “我今天讲哈希算法！” 和 “我今天讲哈希算法”。虽然这两个文本只有一个感叹号的区别，但它们的哈希值也是完全不同的。

```
MD5("我今天讲哈希算法！") = 425f0d5a917188d2c3c3dc85b5e4f2cb
MD5("我今天讲哈希算法 ") = a1fb91ac128e6aa37fe42c663971ac3d
```

同样，我们也很难通过哈希值 “a1fb91ac128e6aa37fe42c663971ac3d” 反推出对应的文本 “我今天讲哈希算法”。

此外，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中。比如，一篇包含 4000 字的文章，用 MD5 计算哈希值，也用不了 1ms 的时间。

哈希算法的应用非常多，最常见的有：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储等。

#### 2. 应用一：安全加密

最常用于加密的的哈希算法是 MD5 （MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA （Secure Hash Algorithm，安全散列算法），此外，还有 DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。

对于用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，这正是我们加密的目的。第二就是散列冲突的概率要很小，然而，实际上，不管是什么哈希算法，我们只能做到尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。

**鸽巢原理，也就抽屉原理**，就是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有两个鸽子在同一个鸽巢内。

哈希算法产生的哈希值的长度是固定且有限的，因此，其能表示的数据是有效的，而我们要哈希的数据是无穷的，就必然会存在哈希值相同的情况。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。

如下这两段字符串经过 MD5 哈希算法加密之后，产生的哈希值就是相同的。

![](https://upload-images.jianshu.io/upload_images/11895466-6a7ea9854ac14b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

不过，即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极小，所以相对来说还是很难破解的。

除此之外，没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也就越长。我们在实际的开发中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。

#### 3. 应用二：唯一标识

如果要在海量的图库中搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同而图片内容相同的情况。

我们知道，任何文件在计算中都可以表示成二进制码串。因此，一种方法就是直接将要查找图片的二进制码串与图库中所有图片的二进制码串一一比对，但这样的比对显然非常耗时。

我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，中间取 100 个字节，结尾再取 100 个字节，然后放在一起通过哈希算法得到一个哈希值，作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，就可以减少很多工作量。

如果还想继续提高效率，我们可以把每一个图片的唯一标识和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片做唯一标识，然后在散列表中查找是否存在这个标识。

如果不存在，说明图片不在图库中；如果存在，我们再通过散列表中存储的文件路径作进一步的对比看是否完全一样。如果一样，就说明图片已经存在；如果不一样，说明两张图片尽管唯一标识相同，但并不是相同的图片。

#### 4. 应用三：数据校验

BT 下载的原理是基于 P2P 协议的，我们从多个机器上并行下载一个 2GB 的电影，这个电影可能会被分割成很多文件块（比如 100 块）。等所有文件块都下载完成后，再组装成一个完整的电影文件就行了。

但是，网络传输是不安全的，下载的文件块可能是被宿主机器恶意修改过的，又或者下载过程中出了错误，所以下载的文件块可能是不完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最后合并后的电影无法观看，甚至导致电脑中毒。

这时候，我们可以通过哈希算法，对 100 个文件分别取哈希值，并且保存在种子文件中。这样，只要文件块的内容有一丁点的改变，最后计算出来的哈希值就会完全不同。我们就可以通过比对两次的哈希值来确定文件是否是完全正确的。

#### 5. 应用四：散列函数

散列函数是设计一个散列表的关键，它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址或者链表法来解决。

不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值能否平均分布，也就是说，一组数据是否能均匀地散列在各个槽中。

此外，散列函数的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。

#### 6. 解答开篇

存储网站用户数据的时候，我们可以对用户密码加密之后再存储，不过最好选择相对安全的加密算法，但仅仅这样就万事大吉了吗？

如果用户信息被 “脱库”，黑客虽然拿到的是加密之后的密文，但可以通过猜的方式来破解密码，太过简单的密码这时候就很容易被猜中。

**字典攻击**。我们需要维护一个常用密码的字典表，把字典中的每个密码都用哈希算法计算哈希值，然后拿哈希值和脱库之后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。之所以说基本上可以认为，是因为哈希算法有可能存在散列冲突，虽然密文相同，但与之对应的明文可能也不一样。

针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过，安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，都只是增加攻击的成本而已。

[参考资料-极客时间专栏《数据结构与算法之美》](https://time.geekbang.org/column/126)

获取更多精彩，请关注「seniusen」! 
![](https://upload-images.jianshu.io/upload_images/11895466-ee82f7655f20bfeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
