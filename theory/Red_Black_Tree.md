#### 1. 实现红黑树的基本思想

实际上，红黑树是有固定的平衡过程的：**遇到什么样的节点分布，我们就对应怎么去调整**。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。

首先，我们需要再来看一下红黑树的定义：

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。

在插入、删除节点的过程中，第三、四点要求可能会被破坏，所以“平衡调整”，实际上就是把被破坏的第三、四点恢复过来。

在调整过程中有两个非常重要的操作，左旋（rotate left）和右旋（rotate right），左旋其实就是**围绕某个节点的左旋**，而右旋就是**围绕某个节点的右旋**。

![](https://upload-images.jianshu.io/upload_images/11895466-414773fe002e76f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 2. 插入操作的平衡调整

红黑树规定，**插入的节点必须是红色的**。而且，二叉查找树中新插入的节点都是放在叶子节点上。所以，插入操作的平衡调整，有这样两种特殊情况：

- 如果插入节点的父节点是黑色的，那我们什么都不做，它仍然满足红黑树的定义。
- 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。

除此之外，其它情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基本的操作：**左右旋转和改变颜色**。

红黑树的平衡调整是一个迭代的过程，我们把正在处理的节点叫作**关注节点**，关注结点会随着迭代的进行而不断变化，最初的关注节点就是新插入的节点。

新节点插入后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续保持平衡。

为了简化描述，我们把父节点的兄弟节点叫作叔叔结点，父节点的父节点叫作祖父节点。

**CASE 1 ：如果关注节点是 a，它的叔叔结点 d 是红色，我们就依次执行下面的操作**：

- 将关注节点 a 的父节点 b 、叔叔结点 d 的颜色都设置成黑色；
- 将关注节点 a 的祖父节点 c 的颜色设置成红色；
- 关注节点变成 a 的祖父节点 c；
- 跳到 CASE 2 或者 CASE 3。

![](https://upload-images.jianshu.io/upload_images/11895466-88d0fe54b69fb7e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**CASE 2 ：如果关注节点是 a，它的叔叔结点 d 是黑色，关注节点 a 是其父结点 b 的右子节点，我们就依次执行下面的操作**：

- 关注节点变成 a 的父节点 b；
- 围绕新的关注节点 b 左旋；
- 跳到 CASE 3。

![](https://upload-images.jianshu.io/upload_images/11895466-8a680f1123acc8c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**CASE 3 ：如果关注节点是 a，它的叔叔结点 d 是黑色，关注节点 a 是其父结点 b 的左子节点，我们就依次执行下面的操作**：

- 围绕关注节点 a 的祖父节点 c 右旋；
- 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换；
- 调整结束。

![](https://upload-images.jianshu.io/upload_images/11895466-3522fa9d55258a15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 3. 删除操作的平衡调整

删除操作的平衡调整分为两步，第一步是**针对删除节点初步调整**。初步调整是保证整棵红黑树在一个节点删除之后，仍然满足第四条的定义。第二步是**针对关注节点进行二次调整**，让它满足红黑树的的第三条定义。

##### 3.1. 针对删除节点初步调整

经过初步调整后，为了保证红黑树的第四条要求，有些节点会被标记为两种颜色，“红-黑” 或者 “黑-黑”，如果一个节点被标记为了 “黑-黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。

下面，如果一个节点既可以是红色，也可以是黑色，我们用一半黑色一半红色来表示。如果一个节点是 “红-黑” 或者 “黑-黑”，我们用左上角的一个小黑点来表示。

**CASE 1 ：如果要删除的节点是 a，它只有一个子节点 b，我们就依次执行下面的操作**：

- 删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作和普通的二叉查找树的删除操作一样；
- 节点 a 只能是黑色，结点 b 也只能是红色，其它情况均不符合红黑树的定义。这种情况下，我们把节点 b 改成黑色；
- 调整结束，不需要进行二次调整；

![](https://upload-images.jianshu.io/upload_images/11895466-5efbb027382ab188.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**CASE 2 ：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是它的右子节点 c，我们就依次执行下面的操作**：

- 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置，这一部分操作和普通的二叉查找树的操作无异；
- 然后把节点 c 的颜色设置为和节点 a 相同的颜色；
- 如果节点 c 是黑色，为了不违反红黑树的第四条定义，我们给节点 c 的右子节点 d 多加一个黑色，这时候节点 d 就成了 “红-黑” 或者 “黑-黑”；
- 这时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。

![](https://upload-images.jianshu.io/upload_images/11895466-ad89917ce182d076.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**CASE 3 ：如果要删除的节点 a 有两个非空子节点，并且它的后继节点不是右子节点，我们就依次执行下面的操作**：

- 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；
- 将节点 a 替换成后继节点 d；
- 把节点 d 的颜色设置成和节点 a 相同的颜色；
- 如果节点 d 是黑色，为了不违反红黑树的第四条定义，我们给节点 d 的右子节点 c 多加一个黑色，这时候节点 c 就成了 “红-黑” 或者 “黑-黑”；
- 这时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。

![](https://upload-images.jianshu.io/upload_images/11895466-bf1f460ee345866a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##### 3.2. 针对关注节点进行二次调整

经过初步调整之后，关注节点变成了 “红-黑” 或者 “黑-黑” 节点，针对这个关注节点，我们再分四种情况来进行二次调整，二次调整是为了让红黑树中不存在相邻的红色节点。

**CASE 1 ：如果关注节点是 a，它的兄弟节点 c 是红色的，我们就依次执行下面的操作**：

- 围绕关注节点 a 的父节点 b 左旋；
- 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
- 关注节点不变；
- 继续从四种情况中选择合适的规则来调整。

![](https://upload-images.jianshu.io/upload_images/11895466-54d23ad2a290d839.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**CASE 2 ：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的，我们就依次执行下面的操作**：

- 将关注节点 a 的兄弟节点 c 的颜色变成红色；
- 从关注节点 a 中去掉一个黑色，这个时候关注节点 a 就是单纯的红色或者黑色；
- 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了 “红-黑” 或者 “黑-黑”；
- 关注节点从 a 变成其父节点 b；
- 继续从四种情况中选择合适的规则来调整。

![](https://upload-images.jianshu.io/upload_images/11895466-f709c51618e81467.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**CASE 3 ：如果关注节点是 a，它的兄弟节点 c 是黑色的， c 的左子节点 d 是红色，c 的右子节点 e 是黑色，我们就依次执行下面的操作**：

- 围绕关注节点 a 的兄弟节点 c 右旋；
- 节点 c 和节点 d 交换颜色；
- 关注节点不变；
- 跳到 CASE 4 继续调整。

![](https://upload-images.jianshu.io/upload_images/11895466-fb4154dee63ccc3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**CASE 4 ：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的，我们就依次执行下面的操作**：

- 围绕关注节点 a 的父节点 b 左旋；
- 将关注节点 a 的兄弟节点 c 的颜色，和关注节点 a 的父节点 b 设置成相同的颜色；
- 将关注节点 a 的父节点 b 的颜色设置成黑色；
- 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；
- 将关注节点 a 的叔叔结点 e 设置成黑色；
- 调整结束。

![](https://upload-images.jianshu.io/upload_images/11895466-ce918f788479acbc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 4. 红黑树为什么要求叶子节点是黑色的空节点？

之所以有这么奇怪的要求，其实就是为了实现方便。只要满足这一条要求，那在任何时刻的平衡操作就都可以归结为上述的几种情况。

下面我们来看一个叶子节点如果不为黑色的情况。

![](https://upload-images.jianshu.io/upload_images/11895466-f44c02cbbeea6af0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当插入一个红色节点时，红黑树的定义就被破坏了，而这个时候这种情况也不满足上述的三种情况。但如果我们加上黑色的空节点后，它就满足 CASE 2 了。另外，我们也可以对每种情况的条件进行修改，但那样的话规则就没有原来那么简洁了。

![](https://upload-images.jianshu.io/upload_images/11895466-8ec96e7dad811b7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

另外，我们并不是给每个黑色的空的叶子节点都分配一块内存，而是共用一个就行，这样也不会导致存储空间的极大浪费。

![](https://upload-images.jianshu.io/upload_images/11895466-944ac26f3e758d3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 5. 小结
 - 红黑树的确非常复杂，但只要对照着上述这几种情况，按照固定操作实现即可，不要过分纠结于算法本身的正确性；
- 找准关注节点，一切操作都是以关注节点来操作的；

[参考资料-极客时间专栏《数据结构与算法之美》](https://time.geekbang.org/column/126)

获取更多精彩，请关注「seniusen」! 
![](https://upload-images.jianshu.io/upload_images/11895466-ee82f7655f20bfeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
